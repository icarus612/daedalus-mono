builtin.append(<i>slice</i>, <i>elems</i>) | <b>Builtin function</b> that end built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:  |  | func append(slice []Type, elems ...Type) []Type 
builtin.cap(<i>v</i>) | <b>Builtin function</b> that cap built-in function returns the capacity of v, according to its type:  |  | func cap(v Type) int 
builtin.clear(<i></i>) | <b>Builtin function</b> that ear built-in function clears maps and slices. For maps, clear deletes all entries, resulting in an empty map. For slices, clear sets all elements up to the length of the slice to the zero value of the respective element type. If the argument type is a type parameter, the type parameter's type set must contain only map or slice types, and clear performs the operation implied by the type argument.  |  | func clear[T ~[]Type | ~map[Type]Type1](t T) 
builtin.close(<i>c</i>) | <b>Builtin function</b> that ose built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form  |  | func close(c chan<- Type) 
builtin.complex(<i>r</i>, <i>i</i>) | <b>Builtin function</b> that lex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).  |  | func complex(r, i FloatType) ComplexType 
builtin.copy(<i>dst</i>, <i>src</i>) | <b>Builtin function</b> that opy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).  |  | func copy(dst, src []Type) int 
builtin.delete(<i>m</i>, <i>key</i>) | <b>Builtin function</b> that ete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.  |  | func delete(m map[Type]Type1, key Type) 
builtin.imag(<i>c</i>) | <b>Builtin function</b> that mag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.  |  | func imag(c ComplexType) FloatType 
builtin.len(<i>v</i>) | <b>Builtin function</b> that len built-in function returns the length of v, according to its type:  |  | func len(v Type) int 
builtin.make(<i>t</i>, <i>size</i>) | <b>Builtin function</b> that ake built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:  |  | func make(t Type, size ...IntegerType) Type 
builtin.max(<i></i>) | <b>Builtin function</b> that max built-in function returns the largest value of a fixed number of arguments of cmp.Ordered types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, max will return NaN.  |  | func max[T cmp.Ordered](x T, y ...T) T 
builtin.min(<i></i>) | <b>Builtin function</b> that min built-in function returns the smallest value of a fixed number of arguments of cmp.Ordered types. There must be at least one argument. If T is a floating-point type and any of the arguments are NaNs, min will return NaN.  |  | func min[T cmp.Ordered](x T, y ...T) T 
builtin.new(<i>Type</i>) | <b>Builtin function</b> that new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.  |  | func new(Type) *Type 
builtin.panic(<i>v</i>) | <b>Builtin function</b> that nic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover.  |  | func panic(v any) 
builtin.print(<i>args</i>) | <b>Builtin function</b> that int built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.  |  | func print(args ...Type) 
builtin.println(<i>args</i>) | <b>Builtin function</b> that tln built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.  |  | func println(args ...Type) 
builtin.real(<i>c</i>) | <b>Builtin function</b> that eal built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.  |  | func real(c ComplexType) FloatType 
builtin.recover(<i></i>) | <b>Builtin function</b> that ver built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, recover returns nil.  |  | func recover() any 
