<b>Promise name</b>: Promise.all(<i>iterable</i>) | <b>Promise name</b> that returns a single promise from a list of promiseswhen all promises fulfill. |  | Promise.all(<i>iterable</i>) | // Create a Promise<br/> const myPromise1 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 200, "King");<br/> });<br/> <br/> // Create another Promise<br/> const myPromise2 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 100, "Queen");<br/> });<br/> <br/> // Both resolve, who is faster?<br/> Promise.all([myPromise1, myPromise2]).then((x) =&gt; {<br/>   myDisplay(x);<br/> });<br/> |  
<b>Promise name</b>: Promise.allSettled(<i>iterable</i>) | <b>Promise name</b> that returns a single promise from a list of promiseswhen all promises sette. |  | Promise.allSettled(<i>iterable</i>) | // Create a Promise<br/> const myPromise1 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 200, "King");<br/> });<br/> <br/> // Create another Promise<br/> const myPromise2 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 100, "Queen");<br/> });<br/> <br/> // Settle All<br/> Promise.allSettled([myPromise1, myPromise2]).then((results) =&gt;<br/>   results.forEach((x) =&gt; myDisplay(x.status)),<br/> ); |  
<b>Promise name</b>: Promise.any(<i>iterable</i>) | <b>Promise name</b> that returns a single promise from a list of promiseswhen any promise fulfills. |  | Promise.any(<i>iterable</i>) | // Create a Promise<br/> const myPromise1 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 200, "King");<br/> });<br/> <br/> // Create another Promise<br/> const myPromise2 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 100, "Queen");<br/> });<br/> <br/> // Run when any promise fulfill<br/> Promise.any([myPromise1, myPromise2]).then((x) =&gt; {<br/>   myDisplay(x);<br/> }); |  
<b>Promise name</b>: Promise.race(iterable) | <b>Promise name</b> that returns a single promise from a list of promiseswhen the faster promise settles. |  | Promise.race(iterable) | // Create a Promise<br/> const myPromise1 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 200, "King");<br/> });<br/> <br/> // Create another Promise<br/> const myPromise2 = new Promise((resolve, reject) =&gt; {<br/>   setTimeout(resolve, 100, "Queen");<br/> });<br/> <br/> // When the faster promise settles<br/> Promise.race([myPromise1, myPromise2]).then((x) =&gt; {<br/>   myDisplay(x);<br/> });<br/> |  
<b>Promise name</b>: Promise.reject(message) | <b>Promise name</b> that returns a promise object rejected with a value. |  | Promise.reject(message) | Promise.reject("Not Allowed"); |  
<b>Promise name</b>: Promise.resolve(message) | <b>Promise name</b> that returns a promise object resolved with a value. |  | Promise.resolve(message) | Promise.resolve("All Well"); |  
<b>Promise name</b>: <i>promise</i>.catch(<em>rejected()</em>) | <b>Promise name</b> that provides a function to be called when a promise is rejected. |  | <i>promise</i>.catch(<em>rejected()</em>) | myPromise.catch(x =&gt; myDisplay(x)); |  
<b>Promise name</b>: <i>promise</i>.finally(<em>settled()</em>) | <b>Promise name</b> that provides a function to be called when a promise is fulfilled or rejected. |  | <i>promise</i>.finally(<em>settled()</em>) | myPromise.finally(myDisplay("Settled")); |  
<b>Promise name</b>: <i>promise</i>.then(<em>fulfilled(), rejected()</em>) | <b>Promise name</b> that provide two functions to be called when a promise is fulfilled or rejected. |  | <i>promise</i>.then(<em>fulfilled(), rejected()</em>) | myPromise.then(x =&gt; myDisplay(x), x =&gt; myDisplay(x)); |  
